<!DOCTYPE html>
<html lang="en">
<head>
  <!-- existing head content -->
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #121212;
      color: #f5f5f5;
      font-family: Helvetica, sans-serif;
      margin: 0;
      padding: 0;
    }
    .scrub-timeline {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1e1e1e;
      display: flex;
      gap: 12px;
      overflow-x: auto;
      padding: 12px 16px;
      border-top: 1px solid #333;
      z-index: 50;
    }
    .marker {
      background: #C7FE2E;
      color: #1a1a1a;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
      white-space: nowrap;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.3s;
    }
    .marker:hover {
      background: #e2ff5f;
      transform: scale(1.05);
    }
    .timeline-item video {
      border: 2px solid #444;
      transition: border-color 0.3s;
    }
    .timeline-item video:hover {
      border-color: #C7FE2E;
    }
    .timeline-item span {
      color: #aaa;
    }
  </style>
</head>
<body>
  <!-- existing body content -->
  <div class="scrub-timeline" id="scrubTimeline"></div>

  <script>
    const { createFFmpeg, fetchFile } = FFmpeg;
    const ffmpeg = createFFmpeg({ log: true });

    async function trimClip(blob, startSec, durationSec) {
      if (!ffmpeg.isLoaded()) await ffmpeg.load();
      const fileName = 'input.mp4';
      const outName = 'output.mp4';
      ffmpeg.FS('writeFile', fileName, await fetchFile(blob));
      await ffmpeg.run('-ss', `${startSec}`, '-i', fileName, '-t', `${durationSec}`, '-c', 'copy', outName);
      const trimmedData = ffmpeg.FS('readFile', outName);
      return new Blob([trimmedData.buffer], { type: 'video/mp4' });
    }

    function updateTimeline() {
      const timeline = document.getElementById("timeline");
      const scrubTimeline = document.getElementById("scrubTimeline");
      timeline.innerHTML = "";
      scrubTimeline.innerHTML = "";
      rallyClips.forEach((clip, index) => {
        const div = document.createElement("div");
        div.className = "timeline-item";
        const thumb = document.createElement("video");
        thumb.src = clip.url;
        thumb.muted = true;
        thumb.playsInline = true;
        thumb.autoplay = true;
        thumb.loop = true;
        thumb.onclick = () => replayRally(clip.url);
        const label = document.createElement("span");
        label.innerText = clip.filename ? clip.filename.substring(0, 3) : ("Rally " + (index + 1));
        div.appendChild(thumb);
        div.appendChild(label);
        timeline.appendChild(div);

        const marker = document.createElement("div");
        marker.className = "marker";
        marker.innerText = `${clip.filename.substring(0, 3)} - ${clip.timestamp}`;
        marker.onclick = () => replayRally(clip.url);
        scrubTimeline.appendChild(marker);
      });
    }

    async function uploadToFirebase(blob) {
      try {
        let useTrim = confirm("Would you like to trim this clip before upload?");
        if (useTrim) {
          let start = parseFloat(prompt("Trim start (seconds):", "0"));
          let dur = parseFloat(prompt("Trim duration (seconds):", "10"));
          if (!isNaN(start) && !isNaN(dur)) {
            blob = await trimClip(blob, start, dur);
          }
        }
        let customName = prompt("Rename this clip (optional, no extension):");
        const storageRef = storage.ref();
        const fileName = customName ? `${customName}.mp4` : getFormattedFileName();
        const fileRef = storageRef.child('rallies/' + fileName);
        const metadata = { contentType: 'video/mp4' };
        const snapshot = await fileRef.put(blob, metadata);
        const downloadURL = await snapshot.ref.getDownloadURL();
        return { url: downloadURL, filename: fileName };
      } catch (error) {
        alert("Error uploading clip: " + error.message);
      }
    }
  </script>
</body>
</html>
